НАСЛЕДОВАНИЕ
public class A {  // A — класс родитель.

    private int x;
    public A(int x) {
        this.x = x;
    }
    public void method() {
        System.out.println("A" + x);
    }
    public void method2() {
        System.out.println("AA");
    }
}

public claass B extends A {  // B — класс потомок.  В наследует у А все поля и методы.
//етод met класса А переопределён в классе B.

public int y;
  public void method() {
        System.out.println("B" + x);
    }
    public void method3() {
        System.out.println("BB");
    }

    public static void main(String[] args) {
        B b = new B();
        b.x = 1;
        b.y = 2;
        b.method();
        b.method2();
        b.method3();

    }
}
------------------------------------------------------------------------------------------------
ЗАТЕМНЕНИЕ ПОЛЕЙ

// Поля не переопределяются, но скрываются.
  • Тип поля при сокрытии можно изменить.
  • Поле базового класса при сокрытии продолжает существовать, но недоступно непосредственно по имени
class A2 {  // A2 — класс родитель.
private int x;
public void method() {
    System.out.println("A2" + x);
}
}

class B2 extends A2 {  // B2 — класс потомок.
public int x;
public void method2() {
    System.out.println("B2" + x);
}
   public static void main(String[] args) {
        B2 b = new B2();
        b.x = 5;
        b.method(); // A2=0
        b.method2(); // B2=5
    }
}
}

------------------------------------------------------------------------------------------------
FINAL МЕТОДЫ И КЛАССЫ
final class A3 {  // A3 — final класс: нет наследников.
public void method() {
    System.out.println("A3");
}
}

class A4 { // final метод: невозможно переопределение  в наследнике
public final void method() {
    System.out.println("A4");
}
}

--------------------------------------------------------------------------------------------
КОНСТРУКТОРЫ ПРИ НАСЛЕДОВАНИИ
class A5 {  // A5 — класс родитель.
public A5() {
    System.out.println("A5");    // конструктор родительского класса
}
}

class B5 extends A5 {  // B5 — класс потомок.
public B5() {
    super(); // конструктор потомка Первой строкой в конструкторе всегда стоит super() или this().
    System.out.println("B5");
}
} // При создании потомка следует инициализировать все поля родителя (т. к. они наследуются),
//поэтому нужен вызов конструктора.
---------------------------------------------------------------------------------------------
ВЫЗОВ ПЕРЕГРУЖЕННЫХ КОНСТРУКТОРОВ
class A6 {  // A6 — класс родитель.
A6(int x) {
    System.out.println("A6" + x);
}
A6() {
    System.out.println("A6");
}
}

class B6 extends A6 {  // B6 — класс потомок.
B6(int x) {
    super(x); // конструктор потомка Первой строкой в конструкторе всегда стоит super() или this().
}
B6() {
    System.out.println("B6");
}
}
public static void main(String[] args) {
    new B6(); // на экран выводится "А6"  "Б6"
    new B6(5); // на экран выводится "А6"  "Б6=5"
}
------------------------------------------------------------------------------------------------
ВТОРОЙ КОНТЕКСТ SUPER   Super как ссылка на объект класса родителя.
class A7 {  // A7 — класс родитель.
public void method() {
    System.out.println("method in A7");
}
}

class B7 extends A7 {  // B7 — класс потомок.
public void method() {
    System.out.println("method in B7");
    super.method(); // вызов метода родителя
}
   public static void main(String[] args) {
        B7 b = new B7();
        b.method(); // на экран выводится "method in B7" "method in A7"
    }
}
--------------------------------------------------------------------------------------------
НАСЛЕДОВАНИЕ: ПОСТРОЕНИЕ ИЕРАРХИЙ
Критерии определения ситуации наследования:
1. Расширение:класс потомок что-то меняет или добавляет к телу родителя
2. IS-A: объекты класса потомка являются подмножеством объектов класса родителя

1. Простота выбора нужного класса. Если нужен класс
определенного типа, смотри всех, кто от этого
типа наследуется.
2. Единообразие использования. Несмотря на то, что класс наследник может
иметь дополнительные поля и методы либо переопределять
существующие методы, идеологически этот класс не будет отличаться от
родителя.
3. Гарантия состояния. Корень иерархии может наложить ограничения на
значения полей (выполнить инкапсуляцию), которые уже не могут быть
нарушены классами потомками, так как доступа к приватным полям у
потомков не будет, и для присвоения значений придётся использовать
родительские сеттеры. При переопределении сеттеров можно наложить
дополнительные условия, но отменить родительские — не выйдет.

---------------------------------------------------------------------------------------------
ОТНОШЕНИЕ IS-A  (является-а)
Избушка Is-A Строение = "Венно"   ->   Множество зданий   ->    Подмножество избушек

Овал is-A Круг   "Неверно"    -> Множество овалов   ->    Подмножество кругов

---------------------------------------------------------------------------------------

АБСТРАКТНЫЕ КЛАССЫ

abstract class Root {  // Root — класс родитель.
private int x;
public Root(int x) {
if (x < 0) throw new IllegalArgumentException("x must be > 0");
    this.x = x;
}
abstract void printSmthng();
public int getX() {
return x;
}
public void setX(int x) {
    if (x < 0) throw new IllegalArgumentException("x must be > 0");
    this.x = x;
}
}
• Абстрактные классы описывают не объекты, а иерархию.
• Тело у абстрактных классов нормальное, также они могут (но не обязаны) иметь абстрактные методы.
• Абстрактные методы описывают сигнатуру без реализации.
• Класс с абстрактными методами обязан быть абстрактным.
• Расширяющий класс может перекрыть своими абстрактными методами родительские реализованные методы.
• Абстрактный класс не обязан иметь абстрактные методы.
• Создавать объекты абстрактных типов нельзя.

На слайде представлен абстрактный класс Root, который может использоваться
как корень иерархии для некоторых классов. Абстрактность класса означает, что
он предназначен для наследования и не может использоваться для создания
объектов. При попытке создать объект класса Root произойдёт ошибка
компиляции. В задачи абстрактного класса входит создание базовой структуры,
общей для всех классов наследников.
Класс Root требует, чтобы все наследники имели х, причём его всегда можно
узнать и изменить. При этом следует иметь ввиду, что х никогда не может быть
меньше 0. Создание объекта обязано требовать указание числа х.
Дополнительной особенностью является наличие абстрактного метода
printSmthng. Абстрактные методы могут существовать только в абстрактных
классах. Для абстрактного метода полностью указывается сигнатура, однако не
пишется тело. Такой метод может использоваться в тех случаях, когда в корне
иерархии уже известно, что метод должен существовать у всех потомков, однако
у него нет общего для всех потомков поведения.
В случае, если класс наследуется от такого родителя, у которого есть
15
абстрактный метод, то потомок должен либо определить его тело, либо сам
быть абстрактным.
Обратите внимание, что абстрактный класс во всех отношениях является таким
же, но он:
1. Может, но не обязан, иметь абстрактные методы.
2. Не может быть инстанциирован, так как предназначен для наследования.
Таким образом, чаще всего наследование предполагает наличие абстрактного
класса, от которого наследуются остальные классы, входящие в его иерархию.

--------------------------------------------------------------------------------------------
АГРЕГАЦИЯ • Классы, которые хранят другие объекты, называются агрегатами.
class Engine {
    int power;
    public Engine(int power) {
        this.power = power;
    }
}
class Car {
    String model = "Porsche";
    Engine engine;
    public Car(Engine someEngine) {
        this.engine = someEngine;
    }
}
Engine goodEngine = new Engine(200);
Car porsche = new Car(goodEngine);
System.out.println(porsche.model);

Здесь есть два класса Engine и Car, экземпляр Engine создается отдельно и
передаётся как параметр конструктора при создании экземпляра Car.
----------------------------------------------------------------------------------------
КОМПОЗИЦИЯ • Классы, которые состоят из других классов, называются
Композиция подразумевает, что ассоциированный объект — «подобъект»,
составная часть, не имеющая смысла без ссылающегося. На практике,
например, отношение композиции появляется, когда мы выделяем часть
свойств объекта в отдельную сущность.
Дом может содержать несколько комнат — нет независимой жизни комнаты, и
любая комната не может принадлежать двум различным домам. Если мы
удалим дом, то автоматически должны удалить и комнаты.
class Engine {
    int power;
    public Engine(int power) {
        this.power = power;
    }
}
class Car {
    String model = "Porsche";
    Engine engine;
    public Car() {
        this.engine = new Engine(200);
    }
}
Здесь те же классы Engine и Car, однако экземпляр Engine создаётся
непосредственно при создании экземпляра Car и не может существовать без
него.
Таким образом, у этих классов теперь более жёсткая связанность.
-------------------------------------------------------------------------------------------------

Итоги
Наследование может быть использовано как отношение,в которомродитель — это шаблон для потомка.
Наследование используется для создания логически сгруппированных иерархий.
Наследуются поля и методы.
Методы можно переопределить, поля можно затемнить.
Запретить наследование или переопределение можно с помощью final
Проверить адекватность наследования можно с помощью тестов:
• расширяет ли потомок родителя,
• выполняется ли IS-A.
Абстрактный класс — это корень иерархии.
Композиция и агрегация могут заменять наследование.




