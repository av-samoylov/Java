

Лямбда-выражение

Лямбда-выражение представляет собой набор инструкций (кусок кода), который можно:

сохранить в переменную (ссылочную),
передать в качестве аргумента в метод,
вызвать в любой момент времени,
использовать несколько раз.
По факту, лямбд-выражение — это упрощённая запись анонимного класса, который реализует функциональный интерфейс.
Но обо всем по порядку!

Пример.

В коллекциях Java есть возможность сортировки элементов коллекции. Если мы хотим сортировать не по умолчанию,
 а применив более сложную логику, то нам нужно использовать некоторый объект, который указывает,
 по какой логике нужно сравнивать и сортировать элементы в коллекции.

В метод Collections.sort(collection, comparator) мы передаём коллекцию для сортировки и comparator,
несущий логику сортировки.

Comparator<T> — это функциональный интерфейс, содержащий в себе единственный метод compare(T obj1, T obj2),
в котором должна быть прописана логика сравнения двух близлежащих элементов коллекции.

Мы можем создать собственный компаратор, например для String, в отдельном классе.
public class MyStringComparator implements Comparator<String> {
   @Override
   public int compare(String o1, String o2) {
       return o1.length() - o2.length();
   }
}

Далее мы создадим объект этого класса и подставим его в Collections.sort(collection, comparator).

Но есть более быстрая запись — создать анонимный класс этого компаратора.
Comparator<String> comparator = new Comparator<String>() {
   public int compare(String obj1, String obj2) {
       return obj1.length() - obj2.length();
   }
};
Collections.sort(list, comparator);

С появлением Java 8 у нас есть возможность иметь ещё более быструю запись для таких целей. Это лямбда-функция.
Comparator<String> comparator = (obj1, obj2) -> obj1.length() - obj2.length();
Collections.sort(list, comparator);

Мы прописываем реализацию единственного метода функцонального интерфейса, записываем эту функцию в локальную переменную
и передаём туда, где нужно её использовать.

Также мы можем иметь и такую запись без создания переменной.
Collections.sort(
       new ArrayList<>(),
       (String obj1, String obj2) -> obj1.length() - obj2.length()
);

-----------------------------------------------------------------------------

Синтаксис лямбда-выражений:

( параметры ) -> { тело метода }

Лямбда-выражения в своей структуре могут иметь один входной параметр, несколько или не иметь их.
 Необходимо указывать параметры либо явно, либо они могут быть получены из контекста.

Например, (int a) можно записать как (a), как в нашем примере, где был явно указан тип String.
При реализации лямбда-функции мы просто указали (obj1, obj2),
но когда создавали лямбда-функцию без явного указания типа,
указывали тип при описании лямбда-функции (String obj1, String obj2).

Параметры, как и везде, заключаются в круглые скобки и разделяются запятыми.
Например (a, b), (int a, int b) или (String a, int b, float c).

Без параметров необходимо использовать пустые круглые скобки. Например () -> 42.
Для одного параметра без указания типа скобки можно опустить,
как и упустить фигурные скобки при единственном операторе.
Например a -> return a*a Так же можно возвращаемое значение в таком случае писать без return a -> a*a.

Примеры лямбда-выражений:
(int a, int b) -> {  return a + b; }
() -> System.out.println("Hello World");
(String s) -> { System.out.println(s); }
() -> 42
() -> { return 3.1415 }
(int a, int b) -> a + b
(a, b) -> a + b
-----------------------------------------------------------------------

Отметим, что блок кода в лямбда-выражении может быть однострочным или многострочным:
Однострочный блок кода
str -> System.out.println(str);
Многострочный блок кода без возвращаемого значения. Указываем в фигурных скобках.
Делать в таком блоке можно всё то же самое, что и в обычном методе (по факту, это и есть обычный метод).
str -> {
   if (str.isEmpty()) {
       str = "Hello World";
   }
   System.out.println(str);
};
Если блок кода явно возвращает значение, необходимо возвратить его через return.
str -> {
   boolean boolean = s.isEmpty();
   return boolean;
}


В Java есть много встроенных функциональных интерфейсов, рассмотрим основные из них.
Название        Описание

Predicate       Проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.
                В качестве параметра лямбда-выражение принимает объект типа T.

Consumer        Выполняет некоторое действие над объектом типа T, при этом ничего не возвращая.

Function        Представляет функцию перехода от объекта типа T к объекту типа R.

Supplier        Не принимает никаких аргументов, но возвращает объект типа T.


---------------------------------------------------------------------------------------------------------------

Задача: переписать реализацию метода printList(ArrayList<Integer>), используя метод списка forEach(),
принимающий лямбда-выражение. Логика работы метода остается той же.
Подсказка: нужно использовать лямбда-выражение, передавая его в метод forEach().
public static void printList(ArrayList list) {
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
Ниже представлен переписанный вариант метода с использованием метода forEach() и лямбда-выражения:
public static void printList(ArrayList<Integer> list) {
    list.forEach(item -> System.out.println(item));
}
Пояснение
•	list.forEach(…): Метод forEach() принимает функциональный интерфейс Consumer, который в данном случае реализован
с помощью лямбда-выражения.
•	Лямбда-выражение (item -> System.out.println(item)): Для каждого элемента списка выполняется операция вывода
этого элемента в консоль.
-----------------------------------------------------------------------------------------------------













































