В использовании OutputStream, InputStream, Writer и Reader мы организуем цепочку обработки данных следующим образом:

FileInputStream inputStream = new FileInputStream("c:\\file.txt");
InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
String textFromFile = bufferedReader.readLine();

На самом деле, когда мы вызываем bufferedReader.readLine(), поведение под капотом такое:

-> BufferReader вызывает метод read() у объекта InputStreamReader
-> Предыдущий вызывает метод read() у объекта FilreInputStream
-> FileInputStream начинает чтение из файла данных в буфер
--------------------------------------------------------------------------------------------------------
Получить стрим у коллекции мы можем, вызвав метод stream().
ArrayList<String> arrayList = new ArrayList<String>();
Stream<String> listStream = arrayList.stream();

Таким же образом мы можем получить stream и у массива.
String[] stringArray = new String[10];
Stream<String> arrayStream = Arrays.stream(stringArray);

Тип данных стрима можно не указывать.
Stream listStream = arrayList.stream();
Stream arrayStream = Arrays.stream(stringArray);
---------------------------------------------------------------------------------------------

Также есть возможность создать пустой стрим через метод Stream.empty().

Кроме стримов с явным указанием типа Stream<T>, существуют специальные стримы для примитивных типов:

IntStream для int,
LongStream для long,
DoubleStream для double.
Примитивные стримы полезны, так как не нужно тратить время на приведение к нужному типу.
К тому же, у них есть ряд специальных операторов, упрощающих написание кода.
----------------------------------------------------------------------------------------------


Жизненный цикл стрима

Жизненный цикл стрима состоит из трёх последовательных ступеней:

создание стрима,
применение к стриму ряда промежуточных операций,
применение к стриму завершающей операции с целью получения ожидаемого результата.
С созданием стрима мы разобрались. Теперь нужно разобраться с операциями, которые мы можем применять к нему.

Операции делятся на 2 типа: промежуточные и терминальные.

Промежуточные — это операции, которые возвращают изменённый стрим (стрим, к которому применили определенные действия).
К возвращённому стриму можно применить несколько промежуточных операций.

Далее идет последняя операция, которая возвращает нам конкретный ожидаемый результат, — терминальная.
Такая операция у стрима одна и она завершает его жизненный цикл.



Рассмотрим промежуточные операторы:
Оператор  Описание

Stream<T> of()  Создаёт поток из набора объектов

Stream<T> generate()    Генерирует поток по заданному правилу

Stream<T> concat()  Объединяет несколько потоков в один

Stream<T> filter()  Фильтрует данные. Оставляет данные, подходящие под описанное правило.

Stream<T> distinct()    Удаляет дубликаты
Stream<T> sorted()  Сортирует данные
Stream<T> peek()    Выполняет определённое действие над каждым элементом
Stream<T> limit(n)  Обрезает данные после достижения лимита
Stream<T> skip(n)   Пропускает первые n элементов
Stream<T> map()     Преобразует данные из одного типа в другой
Stream<T> flatMap() Преобразует данные из одного типа в другой (немного иначе, чем просто map)


Терминальные операторы:
Оператор    Описание

boolean anyMatch()  Проверяет элементы потока на совпадение заданному правилу хотя бы одного

boolean allMatch()  Проверяет все элементы потока на совпадение заданному правилу

boolean noneMatch() Проверяет все элементы потока на НЕсовпадение заданному правилу

*Optional<T> findFirst()    Возвращает первый соответствующий правилу элемент

*Optional<T> findAny()  Возвращает любой соответствующий правилу элемент
*Optional<T> min()  Ищет минимальный элемент в потоке
*Optional<T> max()  Ищет максимальный элемент в потоке
long count()    Возвращает количество элементов в потоке
R collect()     Все данные из потока возвращаются в виде коллекции

* В некоторых методах возвращается Optional<T>. Optional — служебный класс.
 Его задача — просто хранить в себе ссылку на объект типа T.
 При этом ссылка на объект внутри класса Optional<T> может быть и null.

Класс Optional позволяет «красиво» проверять на null и описывать, что делать, если внутри хранится null.

----------------------------------------------------------------------------------------------------------

Самое интересное: зачем нам нужны стримы и почему они выигрывают коллекции по нескольким пунктам.

Стримы не хранят элементы. Элементы, используемые в стримах, могут храниться в коллекции, либо при необходимости
могут быть напрямую сгенерированы.

Операции со стримами не изменяют источник данных, а лишь возвращают новый стрим с результатами этих операций.
Для стримов характерно отложенное выполнение. Все операции со стримом происходят лишь тогда, когда выполняется
терминальная операция и возвращается конкретный результат, а не новый стрим.

Важно понимать, что Stream API — очень важное и нужное обновление, которое несёт за собой большее удобство
со стороны разработки, улучшение производительности и работы с памятью. Используется повсеместно.

Вместе с выходом Stream API было ещё одно важное обновление, связанное с реализацией функциональных интерфейсов.

--------------------------------------------------------------------------------------------------------------

Функциональные интерфейсы

Очень часто при построении архитектуры выделяют интерфейсы с единственной ответственностью (единственным методом).
Такие интерфейсы обычно несут ответственность за реализацию этого единственного функционала.
Например, есть задача «научить» класс что-то делать. Это действие выделено в отдельный интерфейс.
interface Testable<T> {
   boolean test(T value);
}
В данном интерфейсе, который содержит контракт на тестирование, есть единственный абстрактный метод test(),
который принимает аргумент и возвращает boolean.

Из-за того, что вся логика этого интерфейса определена одним единственным методом,
он называется функциональным интерфейсом. Мы можем поставить ему аннотацию @FunctionalInterface

@FunctionalInterface
interface Testable<T> {
   boolean test(T value);
}
Данная аннотация необязательна, но при её наличии код не скомпилируется, если в интерфейсе будет более одного метода.

Основное назначение функциональных интерфейсов — это использование их при реализации лямбда-выражений.

------------------------------------------------------------------------------------------------------------































